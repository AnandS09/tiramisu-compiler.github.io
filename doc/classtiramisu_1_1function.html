<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Tiramisu Compiler: tiramisu::function Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tiramisu Compiler
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classtiramisu_1_1function.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classtiramisu_1_1function-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tiramisu::function Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class to represent functions in Tiramisu.  
 <a href="classtiramisu_1_1function.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="core_8h_source.html">core.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a41227e14c97d5e18d85797ea9000a646"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a41227e14c97d5e18d85797ea9000a646">function</a> (std::string name)</td></tr>
<tr class="memdesc:a41227e14c97d5e18d85797ea9000a646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a function called <code>name</code>.  <a href="#a41227e14c97d5e18d85797ea9000a646">More...</a><br /></td></tr>
<tr class="separator:a41227e14c97d5e18d85797ea9000a646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b1a049a512671258cf346af4b59ec6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a92b1a049a512671258cf346af4b59ec6">add_context_constraints</a> (const std::string &amp;new_context)</td></tr>
<tr class="memdesc:a92b1a049a512671258cf346af4b59ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a set of constraints to the context of the program.  <a href="#a92b1a049a512671258cf346af4b59ec6">More...</a><br /></td></tr>
<tr class="separator:a92b1a049a512671258cf346af4b59ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab166ee0cecf4afec3d75e17662976e20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ab166ee0cecf4afec3d75e17662976e20">align_schedules</a> ()</td></tr>
<tr class="memdesc:ab166ee0cecf4afec3d75e17662976e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align the schedules of all the computations of this function.  <a href="#ab166ee0cecf4afec3d75e17662976e20">More...</a><br /></td></tr>
<tr class="separator:ab166ee0cecf4afec3d75e17662976e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e42f31722b17263102734867aaaa71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#af3e42f31722b17263102734867aaaa71">allocate_and_map_buffers_automatically</a> ()</td></tr>
<tr class="memdesc:af3e42f31722b17263102734867aaaa71"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each computation, allocate a buffer and map the computation to that buffer.  <a href="#af3e42f31722b17263102734867aaaa71">More...</a><br /></td></tr>
<tr class="separator:af3e42f31722b17263102734867aaaa71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5662551a604ffea619b3bbe385120d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#af5662551a604ffea619b3bbe385120d8">compute_bounds</a> ()</td></tr>
<tr class="memdesc:af5662551a604ffea619b3bbe385120d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounds of each computation.  <a href="#af5662551a604ffea619b3bbe385120d8">More...</a><br /></td></tr>
<tr class="separator:af5662551a604ffea619b3bbe385120d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804d3b074034a155e0c048bb819b96e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a804d3b074034a155e0c048bb819b96e4">dump</a> (bool exhaustive) const </td></tr>
<tr class="memdesc:a804d3b074034a155e0c048bb819b96e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the function on standard output (dump most of the fields of <a class="el" href="classtiramisu_1_1function.html" title="A class to represent functions in Tiramisu. ">tiramisu::function</a>).  <a href="#a804d3b074034a155e0c048bb819b96e4">More...</a><br /></td></tr>
<tr class="separator:a804d3b074034a155e0c048bb819b96e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c65ca8d0b7e7f814e8af97034845e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a70c65ca8d0b7e7f814e8af97034845e8">dump_dep_graph</a> ()</td></tr>
<tr class="memdesc:a70c65ca8d0b7e7f814e8af97034845e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the graph of dependences between computations.  <a href="#a70c65ca8d0b7e7f814e8af97034845e8">More...</a><br /></td></tr>
<tr class="separator:a70c65ca8d0b7e7f814e8af97034845e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346628909ccc3bf0f4e836582a47369c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a346628909ccc3bf0f4e836582a47369c">dump_halide_stmt</a> () const </td></tr>
<tr class="memdesc:a346628909ccc3bf0f4e836582a47369c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a Halide stmt that represents the function.  <a href="#a346628909ccc3bf0f4e836582a47369c">More...</a><br /></td></tr>
<tr class="separator:a346628909ccc3bf0f4e836582a47369c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9967fb7d74a924e8e479ac6ee8aa0f3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a9967fb7d74a924e8e479ac6ee8aa0f3e">dump_iteration_domain</a> () const </td></tr>
<tr class="memdesc:a9967fb7d74a924e8e479ac6ee8aa0f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the iteration domain of the function.  <a href="#a9967fb7d74a924e8e479ac6ee8aa0f3e">More...</a><br /></td></tr>
<tr class="separator:a9967fb7d74a924e8e479ac6ee8aa0f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a4ca9fa5e9577dbb1457642a08771e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a11a4ca9fa5e9577dbb1457642a08771e">dump_schedule</a> () const </td></tr>
<tr class="memdesc:a11a4ca9fa5e9577dbb1457642a08771e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the schedules of the computations of the function.  <a href="#a11a4ca9fa5e9577dbb1457642a08771e">More...</a><br /></td></tr>
<tr class="separator:a11a4ca9fa5e9577dbb1457642a08771e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba881339599024ba4424f5e96496e13b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#aba881339599024ba4424f5e96496e13b">dump_sched_graph</a> ()</td></tr>
<tr class="memdesc:aba881339599024ba4424f5e96496e13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the graph of scheduling relations set by the higher level scheduling functions (e.g.  <a href="#aba881339599024ba4424f5e96496e13b">More...</a><br /></td></tr>
<tr class="separator:aba881339599024ba4424f5e96496e13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf3c028806e84b71daf03140ecd2b26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#abdf3c028806e84b71daf03140ecd2b26">dump_time_processor_domain</a> () const </td></tr>
<tr class="memdesc:abdf3c028806e84b71daf03140ecd2b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump (on stdout) the time processor domain of the function.  <a href="#abdf3c028806e84b71daf03140ecd2b26">More...</a><br /></td></tr>
<tr class="separator:abdf3c028806e84b71daf03140ecd2b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a00f945e60bc4c1188345201cbb1c26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a0a00f945e60bc4c1188345201cbb1c26">dump_trimmed_time_processor_domain</a> () const </td></tr>
<tr class="memdesc:a0a00f945e60bc4c1188345201cbb1c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump (on stdout) the trimmed time processor domain of the function.  <a href="#a0a00f945e60bc4c1188345201cbb1c26">More...</a><br /></td></tr>
<tr class="separator:a0a00f945e60bc4c1188345201cbb1c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330d325efaa557465e583c464fc3e4ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a330d325efaa557465e583c464fc3e4ca">gen_c_code</a> () const </td></tr>
<tr class="memdesc:a330d325efaa557465e583c464fc3e4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate C code and print it on stdout.  <a href="#a330d325efaa557465e583c464fc3e4ca">More...</a><br /></td></tr>
<tr class="separator:a330d325efaa557465e583c464fc3e4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7dc392ea116258b7b66bcf3ef94c72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a3a7dc392ea116258b7b66bcf3ef94c72">gen_halide_obj</a> (const std::string &amp;obj_file_name, Halide::Target::OS os, Halide::Target::Arch arch, int bits) const </td></tr>
<tr class="memdesc:a3a7dc392ea116258b7b66bcf3ef94c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an object file that contains the compiled function.  <a href="#a3a7dc392ea116258b7b66bcf3ef94c72">More...</a><br /></td></tr>
<tr class="separator:a3a7dc392ea116258b7b66bcf3ef94c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59a7d760c7fc07075ca0e94bc8d99c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ac59a7d760c7fc07075ca0e94bc8d99c5">gen_halide_obj</a> (const std::string &amp;obj_file_name) const </td></tr>
<tr class="memdesc:ac59a7d760c7fc07075ca0e94bc8d99c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ac59a7d760c7fc07075ca0e94bc8d99c5">More...</a><br /></td></tr>
<tr class="separator:ac59a7d760c7fc07075ca0e94bc8d99c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd658a57a2a7fce5955ca86405230b89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#abd658a57a2a7fce5955ca86405230b89">gen_halide_stmt</a> ()</td></tr>
<tr class="memdesc:abd658a57a2a7fce5955ca86405230b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Halide stmt that represents the function.  <a href="#abd658a57a2a7fce5955ca86405230b89">More...</a><br /></td></tr>
<tr class="separator:abd658a57a2a7fce5955ca86405230b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919fa276486c0348dd626a3e75d10f0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a919fa276486c0348dd626a3e75d10f0a">gen_cuda_stmt</a> ()</td></tr>
<tr class="separator:a919fa276486c0348dd626a3e75d10f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5792d0b53936a1ab74d2615810adbd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ab5792d0b53936a1ab74d2615810adbd4">gen_isl_ast</a> ()</td></tr>
<tr class="memdesc:ab5792d0b53936a1ab74d2615810adbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an isl AST that represents the function.  <a href="#ab5792d0b53936a1ab74d2615810adbd4">More...</a><br /></td></tr>
<tr class="separator:ab5792d0b53936a1ab74d2615810adbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50be3da8d911d89f7bab886a5ac98976"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a50be3da8d911d89f7bab886a5ac98976">gen_time_space_domain</a> ()</td></tr>
<tr class="memdesc:a50be3da8d911d89f7bab886a5ac98976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the time-space domain of the function.  <a href="#a50be3da8d911d89f7bab886a5ac98976">More...</a><br /></td></tr>
<tr class="separator:a50be3da8d911d89f7bab886a5ac98976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ae28c38afbfbd44b8c73ceb323ec76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#af1ae28c38afbfbd44b8c73ceb323ec76">set_arguments</a> (const std::vector&lt; <a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> * &gt; &amp;buffer_vec)</td></tr>
<tr class="memdesc:af1ae28c38afbfbd44b8c73ceb323ec76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the arguments of the function.  <a href="#af1ae28c38afbfbd44b8c73ceb323ec76">More...</a><br /></td></tr>
<tr class="separator:af1ae28c38afbfbd44b8c73ceb323ec76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1958c4935e7f81bf6b5e8853c2116f39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a1958c4935e7f81bf6b5e8853c2116f39">codegen</a> (const std::vector&lt; <a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> * &gt; &amp;buffer_vec, const std::string obj_filename)</td></tr>
<tr class="memdesc:a1958c4935e7f81bf6b5e8853c2116f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for all the functions required to run code generation of a tiramisu program.  <a href="#a1958c4935e7f81bf6b5e8853c2116f39">More...</a><br /></td></tr>
<tr class="separator:a1958c4935e7f81bf6b5e8853c2116f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f58920ccc2ae149c678e452693a2d9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a1f58920ccc2ae149c678e452693a2d9c">set_context_set</a> (const std::string &amp;context)</td></tr>
<tr class="memdesc:a1f58920ccc2ae149c678e452693a2d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the context of the function.  <a href="#a1f58920ccc2ae149c678e452693a2d9c">More...</a><br /></td></tr>
<tr class="separator:a1f58920ccc2ae149c678e452693a2d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07666f6b68d13ebe0a436c397908e02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ab07666f6b68d13ebe0a436c397908e02">set_context_set</a> (isl_set *context)</td></tr>
<tr class="memdesc:ab07666f6b68d13ebe0a436c397908e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.This function takes an ISL set as input.  <a href="#ab07666f6b68d13ebe0a436c397908e02">More...</a><br /></td></tr>
<tr class="separator:ab07666f6b68d13ebe0a436c397908e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af457b5e0a82d5f72f3b8b79b59176ea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#af457b5e0a82d5f72f3b8b79b59176ea9">add_buffer</a> (std::pair&lt; std::string, <a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> * &gt; buf)</td></tr>
<tr class="memdesc:af457b5e0a82d5f72f3b8b79b59176ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a buffer to the function.  <a href="#af457b5e0a82d5f72f3b8b79b59176ea9">More...</a><br /></td></tr>
<tr class="separator:af457b5e0a82d5f72f3b8b79b59176ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14af8c1e4fbb05b4f0e1d1d521ad8ab1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a14af8c1e4fbb05b4f0e1d1d521ad8ab1">add_computation</a> (<a class="el" href="classtiramisu_1_1computation.html">computation</a> *cpt)</td></tr>
<tr class="memdesc:a14af8c1e4fbb05b4f0e1d1d521ad8ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a computation to the function.  <a href="#a14af8c1e4fbb05b4f0e1d1d521ad8ab1">More...</a><br /></td></tr>
<tr class="separator:a14af8c1e4fbb05b4f0e1d1d521ad8ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4011e84bbce53bf12f3d27d268f3ec6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ab4011e84bbce53bf12f3d27d268f3ec6">add_gpu_block_dimensions</a> (std::string stmt_name, int dim0, int dim1=-1, int dim2=-1)</td></tr>
<tr class="memdesc:ab4011e84bbce53bf12f3d27d268f3ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the dimensions <code>dim0</code>, <code>dim1</code> and <code>dim2</code> of the computation <code>computation_name</code> to be mapped to GPU blocks.  <a href="#ab4011e84bbce53bf12f3d27d268f3ec6">More...</a><br /></td></tr>
<tr class="separator:ab4011e84bbce53bf12f3d27d268f3ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172616662673576c9e6a2338e79e2405"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a172616662673576c9e6a2338e79e2405">add_gpu_thread_dimensions</a> (std::string stmt_name, int dim0, int dim1=-1, int dim2=-1)</td></tr>
<tr class="memdesc:a172616662673576c9e6a2338e79e2405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the dimensions <code>dim0</code>, <code>dim1</code> and <code>dim2</code> of the computation <code>computation_name</code> to be mapped to GPU threads.  <a href="#a172616662673576c9e6a2338e79e2405">More...</a><br /></td></tr>
<tr class="separator:a172616662673576c9e6a2338e79e2405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23c049224f7978085814d78192072fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ab23c049224f7978085814d78192072fb">add_invariant</a> (<a class="el" href="classtiramisu_1_1constant.html">tiramisu::constant</a> param)</td></tr>
<tr class="memdesc:ab23c049224f7978085814d78192072fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an invariant to the function.  <a href="#ab23c049224f7978085814d78192072fb">More...</a><br /></td></tr>
<tr class="separator:ab23c049224f7978085814d78192072fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606a6a8f4743b80e88624335c7d6aa80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a606a6a8f4743b80e88624335c7d6aa80">add_iterator_name</a> (const std::string &amp;it_name)</td></tr>
<tr class="memdesc:a606a6a8f4743b80e88624335c7d6aa80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an iterator to the function.  <a href="#a606a6a8f4743b80e88624335c7d6aa80">More...</a><br /></td></tr>
<tr class="separator:a606a6a8f4743b80e88624335c7d6aa80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad853d05e691fa26254177c09d5157d10"><td class="memItemLeft" align="right" valign="top">isl_union_map *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ad853d05e691fa26254177c09d5157d10">compute_dep_graph</a> ()</td></tr>
<tr class="memdesc:ad853d05e691fa26254177c09d5157d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the graph of dependences between the computations of the function.  <a href="#ad853d05e691fa26254177c09d5157d10">More...</a><br /></td></tr>
<tr class="separator:ad853d05e691fa26254177c09d5157d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd78d8fcd7cd75562a9fb9703afe1af"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#abcd78d8fcd7cd75562a9fb9703afe1af">get_arguments</a> () const </td></tr>
<tr class="memdesc:abcd78d8fcd7cd75562a9fb9703afe1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the arguments of the function.  <a href="#abcd78d8fcd7cd75562a9fb9703afe1af">More...</a><br /></td></tr>
<tr class="separator:abcd78d8fcd7cd75562a9fb9703afe1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7cb24ba7f1a77c00e2dabc3efa167b"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#abd7cb24ba7f1a77c00e2dabc3efa167b">get_buffers</a> () const </td></tr>
<tr class="memdesc:abd7cb24ba7f1a77c00e2dabc3efa167b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a map that represents the buffers of the function.  <a href="#abd7cb24ba7f1a77c00e2dabc3efa167b">More...</a><br /></td></tr>
<tr class="separator:abd7cb24ba7f1a77c00e2dabc3efa167b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9aa0fde85ccad6193fb744e53cd104d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classtiramisu_1_1computation.html">computation</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ad9aa0fde85ccad6193fb744e53cd104d">get_computations</a> () const </td></tr>
<tr class="memdesc:ad9aa0fde85ccad6193fb744e53cd104d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of the computations of the function.  <a href="#ad9aa0fde85ccad6193fb744e53cd104d">More...</a><br /></td></tr>
<tr class="separator:ad9aa0fde85ccad6193fb744e53cd104d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adefae8a99b33f2c78081ea4f012b3b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classtiramisu_1_1computation.html">computation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a3adefae8a99b33f2c78081ea4f012b3b">get_computation_by_name</a> (std::string str) const </td></tr>
<tr class="memdesc:a3adefae8a99b33f2c78081ea4f012b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the computation of the function that has the name <code>str</code>.  <a href="#a3adefae8a99b33f2c78081ea4f012b3b">More...</a><br /></td></tr>
<tr class="separator:a3adefae8a99b33f2c78081ea4f012b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af573a260ce03fd48571e102ccf8c3c8e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#af573a260ce03fd48571e102ccf8c3c8e">get_gpu_block_iterator</a> (const std::string &amp;comp, int lev0) const </td></tr>
<tr class="memdesc:af573a260ce03fd48571e102ccf8c3c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string representing the name of the GPU block iterator at dimension <code>lev0</code>.  <a href="#af573a260ce03fd48571e102ccf8c3c8e">More...</a><br /></td></tr>
<tr class="separator:af573a260ce03fd48571e102ccf8c3c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa73e0ae4d3e1af91a17c2cf8236dedd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#afa73e0ae4d3e1af91a17c2cf8236dedd">get_gpu_thread_iterator</a> (const std::string &amp;comp, int lev0) const </td></tr>
<tr class="memdesc:afa73e0ae4d3e1af91a17c2cf8236dedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string representing the name of the GPU thread iterator at dimension <code>lev0</code>.  <a href="#afa73e0ae4d3e1af91a17c2cf8236dedd">More...</a><br /></td></tr>
<tr class="separator:afa73e0ae4d3e1af91a17c2cf8236dedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c248d059bd2905af000ad983bfde2dc"><td class="memItemLeft" align="right" valign="top">isl_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a0c248d059bd2905af000ad983bfde2dc">get_isl_ctx</a> () const </td></tr>
<tr class="memdesc:a0c248d059bd2905af000ad983bfde2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the isl_ctx associated with this function.  <a href="#a0c248d059bd2905af000ad983bfde2dc">More...</a><br /></td></tr>
<tr class="separator:a0c248d059bd2905af000ad983bfde2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ec5f97912774ffcd55e1c0423071e6"><td class="memItemLeft" align="right" valign="top">Halide::Internal::Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ae3ec5f97912774ffcd55e1c0423071e6">get_halide_stmt</a> () const </td></tr>
<tr class="memdesc:ae3ec5f97912774ffcd55e1c0423071e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Halide statement that represents the whole function.  <a href="#ae3ec5f97912774ffcd55e1c0423071e6">More...</a><br /></td></tr>
<tr class="separator:ae3ec5f97912774ffcd55e1c0423071e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2948ab3eda80bb89ad5ee594e36fbe3a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classtiramisu_1_1constant.html">tiramisu::constant</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a2948ab3eda80bb89ad5ee594e36fbe3a">get_invariants</a> () const </td></tr>
<tr class="memdesc:a2948ab3eda80bb89ad5ee594e36fbe3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector representing the invariants of the function (symbolic constants or variables that are invariant to the function i.e.  <a href="#a2948ab3eda80bb89ad5ee594e36fbe3a">More...</a><br /></td></tr>
<tr class="separator:a2948ab3eda80bb89ad5ee594e36fbe3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574ee164e7f7d0ae9d8beb9e8abe19d8"><td class="memItemLeft" align="right" valign="top">isl_ast_node *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a574ee164e7f7d0ae9d8beb9e8abe19d8">get_isl_ast</a> () const </td></tr>
<tr class="memdesc:a574ee164e7f7d0ae9d8beb9e8abe19d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an ISL AST that represents this function.  <a href="#a574ee164e7f7d0ae9d8beb9e8abe19d8">More...</a><br /></td></tr>
<tr class="separator:a574ee164e7f7d0ae9d8beb9e8abe19d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab341842b5cab456e095b2f1fa9488d2f"><td class="memItemLeft" align="right" valign="top">isl_union_set *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ab341842b5cab456e095b2f1fa9488d2f">get_iteration_domain</a> () const </td></tr>
<tr class="memdesc:ab341842b5cab456e095b2f1fa9488d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the union of all the iteration domains of the computations of the function.  <a href="#ab341842b5cab456e095b2f1fa9488d2f">More...</a><br /></td></tr>
<tr class="separator:ab341842b5cab456e095b2f1fa9488d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2aa299e2469b8b2d7d09ea24efa545"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#add2aa299e2469b8b2d7d09ea24efa545">get_iterator_names</a> () const </td></tr>
<tr class="memdesc:add2aa299e2469b8b2d7d09ea24efa545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the iterator names of the function.  <a href="#add2aa299e2469b8b2d7d09ea24efa545">More...</a><br /></td></tr>
<tr class="separator:add2aa299e2469b8b2d7d09ea24efa545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0da0ef300285b84602af5c461ece41"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#afb0da0ef300285b84602af5c461ece41">get_name</a> () const </td></tr>
<tr class="memdesc:afb0da0ef300285b84602af5c461ece41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the function.  <a href="#afb0da0ef300285b84602af5c461ece41">More...</a><br /></td></tr>
<tr class="separator:afb0da0ef300285b84602af5c461ece41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef38c08c63bc4b506e47dbad01c58f8f"><td class="memItemLeft" align="right" valign="top">isl_set *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#aef38c08c63bc4b506e47dbad01c58f8f">get_program_context</a> () const </td></tr>
<tr class="memdesc:aef38c08c63bc4b506e47dbad01c58f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a set that represents the parameters of the function (an ISL set that represents the parameters and constraints over the parameters of the functions, a parameter is an invariant of the function).  <a href="#aef38c08c63bc4b506e47dbad01c58f8f">More...</a><br /></td></tr>
<tr class="separator:aef38c08c63bc4b506e47dbad01c58f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2bde943038dda60f25e8e9e6eb0c6d"><td class="memItemLeft" align="right" valign="top">isl_union_map *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a2e2bde943038dda60f25e8e9e6eb0c6d">get_schedule</a> () const </td></tr>
<tr class="memdesc:a2e2bde943038dda60f25e8e9e6eb0c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the union of all the schedules of the computations of the function.  <a href="#a2e2bde943038dda60f25e8e9e6eb0c6d">More...</a><br /></td></tr>
<tr class="separator:a2e2bde943038dda60f25e8e9e6eb0c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae5ec8c162c8ca1a5c8e444f1296958"><td class="memItemLeft" align="right" valign="top">isl_union_map *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#afae5ec8c162c8ca1a5c8e444f1296958">get_trimmed_schedule</a> () const </td></tr>
<tr class="memdesc:afae5ec8c162c8ca1a5c8e444f1296958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the union of all the trimmed schedules of the function.  <a href="#afae5ec8c162c8ca1a5c8e444f1296958">More...</a><br /></td></tr>
<tr class="separator:afae5ec8c162c8ca1a5c8e444f1296958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4eb660feb5cf67aec94a758defc315"><td class="memItemLeft" align="right" valign="top">isl_union_set *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#afd4eb660feb5cf67aec94a758defc315">get_time_processor_domain</a> () const </td></tr>
<tr class="memdesc:afd4eb660feb5cf67aec94a758defc315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the union of time-processor domains of each computation in the function.  <a href="#afd4eb660feb5cf67aec94a758defc315">More...</a><br /></td></tr>
<tr class="separator:afd4eb660feb5cf67aec94a758defc315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20cd533003fcf31d7aba5829cafcd49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ac20cd533003fcf31d7aba5829cafcd49">get_vector_length</a> (const std::string &amp;comp, int lev) const </td></tr>
<tr class="memdesc:ac20cd533003fcf31d7aba5829cafcd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the computation <code>comp</code> is vectorized, return its vector length at the loop level <code>lev</code>.  <a href="#ac20cd533003fcf31d7aba5829cafcd49">More...</a><br /></td></tr>
<tr class="separator:ac20cd533003fcf31d7aba5829cafcd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00c5c93c40c6ba0d8779a6c623b3db4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#af00c5c93c40c6ba0d8779a6c623b3db4">is_sched_graph_tree</a> ()</td></tr>
<tr class="memdesc:af00c5c93c40c6ba0d8779a6c623b3db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the usage of high level scheduling comments is valid; i.e.  <a href="#af00c5c93c40c6ba0d8779a6c623b3db4">More...</a><br /></td></tr>
<tr class="separator:af00c5c93c40c6ba0d8779a6c623b3db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62a0194f9dbc0d549fa8074fa920411"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ab62a0194f9dbc0d549fa8074fa920411">gen_ordering_schedules</a> ()</td></tr>
<tr class="memdesc:ab62a0194f9dbc0d549fa8074fa920411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the schedules of the computations of this function to reflect the order specified using the high level scheduling commands.  <a href="#ab62a0194f9dbc0d549fa8074fa920411">More...</a><br /></td></tr>
<tr class="separator:ab62a0194f9dbc0d549fa8074fa920411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e91d4e3ffd5bf6127156ab45fc32e88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a4e91d4e3ffd5bf6127156ab45fc32e88">set_iterator_names</a> (const std::vector&lt; std::string &gt; &amp;it_names)</td></tr>
<tr class="memdesc:a4e91d4e3ffd5bf6127156ab45fc32e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator names of the function.  <a href="#a4e91d4e3ffd5bf6127156ab45fc32e88">More...</a><br /></td></tr>
<tr class="separator:a4e91d4e3ffd5bf6127156ab45fc32e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2392e3cfb3c84a8a58c3ca5941d0d50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ad2392e3cfb3c84a8a58c3ca5941d0d50">should_map_to_gpu_block</a> (const std::string &amp;comp, int lev0) const </td></tr>
<tr class="memdesc:ad2392e3cfb3c84a8a58c3ca5941d0d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the computation <code>comp</code> should be mapped to GPU block at the loop levels <code>lev0</code>.  <a href="#ad2392e3cfb3c84a8a58c3ca5941d0d50">More...</a><br /></td></tr>
<tr class="separator:ad2392e3cfb3c84a8a58c3ca5941d0d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a999642c7e6a817d17660ff731f9412"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a0a999642c7e6a817d17660ff731f9412">should_map_to_gpu_thread</a> (const std::string &amp;comp, int lev0) const </td></tr>
<tr class="memdesc:a0a999642c7e6a817d17660ff731f9412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the computation <code>comp</code> should be mapped to GPU thread at the loop levels <code>lev0</code>.  <a href="#a0a999642c7e6a817d17660ff731f9412">More...</a><br /></td></tr>
<tr class="separator:a0a999642c7e6a817d17660ff731f9412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6b081a16ce8f0ac126e17189bff492"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#aea6b081a16ce8f0ac126e17189bff492">should_parallelize</a> (const std::string &amp;comp, int lev) const </td></tr>
<tr class="memdesc:aea6b081a16ce8f0ac126e17189bff492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the computation <code>comp</code> should be parallelized at the loop level <code>lev</code>.  <a href="#aea6b081a16ce8f0ac126e17189bff492">More...</a><br /></td></tr>
<tr class="separator:aea6b081a16ce8f0ac126e17189bff492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed66bde408f35cd4fdb8b5ae792ec0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a2ed66bde408f35cd4fdb8b5ae792ec0e">should_unroll</a> (const std::string &amp;comp, int lev) const </td></tr>
<tr class="memdesc:a2ed66bde408f35cd4fdb8b5ae792ec0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the computation <code>comp</code> should be unrolled at the loop level <code>lev</code>.  <a href="#a2ed66bde408f35cd4fdb8b5ae792ec0e">More...</a><br /></td></tr>
<tr class="separator:a2ed66bde408f35cd4fdb8b5ae792ec0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce1b2d76899284621d2fb8b42ae7237"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a2ce1b2d76899284621d2fb8b42ae7237">should_vectorize</a> (const std::string &amp;comp, int lev) const </td></tr>
<tr class="memdesc:a2ce1b2d76899284621d2fb8b42ae7237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the computation <code>comp</code> should be vectorized at the loop level <code>lev</code>.  <a href="#a2ce1b2d76899284621d2fb8b42ae7237">More...</a><br /></td></tr>
<tr class="separator:a2ce1b2d76899284621d2fb8b42ae7237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b34f98c6c6b7759a21a73d610b7f23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a30b34f98c6c6b7759a21a73d610b7f23">should_distribute</a> (const std::string &amp;comp, int lev) const </td></tr>
<tr class="memdesc:a30b34f98c6c6b7759a21a73d610b7f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the computation <code>comp</code> should be distributed at the loop level <code>lev</code>.  <a href="#a30b34f98c6c6b7759a21a73d610b7f23">More...</a><br /></td></tr>
<tr class="separator:a30b34f98c6c6b7759a21a73d610b7f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bdda918ab1e5dee9aa4adeeff053a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a96bdda918ab1e5dee9aa4adeeff053a7">needs_rank_call</a> () const </td></tr>
<tr class="memdesc:a96bdda918ab1e5dee9aa4adeeff053a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This computation requires a call to the MPI_Comm_rank function.  <a href="#a96bdda918ab1e5dee9aa4adeeff053a7">More...</a><br /></td></tr>
<tr class="separator:a96bdda918ab1e5dee9aa4adeeff053a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bbaacf8f539fbe2cdcb72f109c1ad6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ab5bbaacf8f539fbe2cdcb72f109c1ad6">lift_mpi_comp</a> (<a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *comp)</td></tr>
<tr class="memdesc:ab5bbaacf8f539fbe2cdcb72f109c1ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lift certain computations for distributed execution to function calls.  <a href="#ab5bbaacf8f539fbe2cdcb72f109c1ad6">More...</a><br /></td></tr>
<tr class="separator:ab5bbaacf8f539fbe2cdcb72f109c1ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b42857aaf7ff54007d5b67efa2d298"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a59b42857aaf7ff54007d5b67efa2d298">lift_dist_comps</a> ()</td></tr>
<tr class="memdesc:a59b42857aaf7ff54007d5b67efa2d298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lift certain computations for distributed execution to function calls.  <a href="#a59b42857aaf7ff54007d5b67efa2d298">More...</a><br /></td></tr>
<tr class="separator:a59b42857aaf7ff54007d5b67efa2d298"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8ec5724b5bbb47dcfa8571f855d20bbe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a8ec5724b5bbb47dcfa8571f855d20bbe">automatically_allocated</a></td></tr>
<tr class="memdesc:a8ec5724b5bbb47dcfa8571f855d20bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps track of allocation computations created using allocate_and_map_buffer_automatically() to schedule them during gen_ordering_schedules.  <a href="#a8ec5724b5bbb47dcfa8571f855d20bbe">More...</a><br /></td></tr>
<tr class="separator:a8ec5724b5bbb47dcfa8571f855d20bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865002ee46e628ee370bdbfa2be9e0d7"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *, std::unordered_map&lt; <a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a865002ee46e628ee370bdbfa2be9e0d7">sched_graph</a></td></tr>
<tr class="memdesc:a865002ee46e628ee370bdbfa2be9e0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores all high level scheduling instructions between computations; i.e.  <a href="#a865002ee46e628ee370bdbfa2be9e0d7">More...</a><br /></td></tr>
<tr class="separator:a865002ee46e628ee370bdbfa2be9e0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb348adb9016451a8eeb799705455edd"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *, std::unordered_map&lt; <a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#aeb348adb9016451a8eeb799705455edd">sched_graph_reversed</a></td></tr>
<tr class="memdesc:aeb348adb9016451a8eeb799705455edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as sched_graph, except in reverse order (from after to before).  <a href="#aeb348adb9016451a8eeb799705455edd">More...</a><br /></td></tr>
<tr class="separator:aeb348adb9016451a8eeb799705455edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587856ea73f0f552cc711091a3b8ced8"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; <a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a587856ea73f0f552cc711091a3b8ced8">starting_computations</a></td></tr>
<tr class="memdesc:a587856ea73f0f552cc711091a3b8ced8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of all computations that have no computation scheduled before them.  <a href="#a587856ea73f0f552cc711091a3b8ced8">More...</a><br /></td></tr>
<tr class="separator:a587856ea73f0f552cc711091a3b8ced8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c71ad05ac2b8c0312dc5ab667e0cf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a67c71ad05ac2b8c0312dc5ab667e0cf4">use_low_level_scheduling_commands</a></td></tr>
<tr class="memdesc:a67c71ad05ac2b8c0312dc5ab667e0cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A boolean set to true if low level scheduling was used in the program.  <a href="#a67c71ad05ac2b8c0312dc5ab667e0cf4">More...</a><br /></td></tr>
<tr class="separator:a67c71ad05ac2b8c0312dc5ab667e0cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class to represent functions in Tiramisu. </p>
<p>A function in Tiramisu is composed of a set of computations (<a class="el" href="classtiramisu_1_1computation.html" title="A class that represents computations. ">tiramisu::computation</a>). </p>

<p>Definition at line <a class="el" href="core_8h_source.html#l00104">104</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a41227e14c97d5e18d85797ea9000a646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tiramisu::function::function </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a function called <code>name</code>. </p>
<p>Function names should not start with _ (an underscore). Names starting with _ are reserved names. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af457b5e0a82d5f72f3b8b79b59176ea9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::add_buffer </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; std::string, <a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> * &gt;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a buffer to the function. </p>
<p>The buffers of the function are either:</p><ul>
<li>buffers passed to the function as arguments, or</li>
<li>buffers that are declared and allocated within the function itself. The first element of the pair is the name of the buffer (it is used as a key), the second element of the pair is a pointer to the buffer. </li>
</ul>

</div>
</div>
<a class="anchor" id="a14af8c1e4fbb05b4f0e1d1d521ad8ab1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::add_computation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> *&#160;</td>
          <td class="paramname"><em>cpt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a computation to the function. </p>
<p>The order in which computations are added to the function is not important. The order of execution is specified using the schedule. This doesn't allow computations with duplicate names. </p>

</div>
</div>
<a class="anchor" id="a92b1a049a512671258cf346af4b59ec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::add_context_constraints </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a set of constraints to the context of the program. </p>
<p>This command is useful for providing constraints over the constants used within a tiramisu function. The context of a function is represented as an ISL set that represents constraints over the parameters of the function (a parameter of a function is a constant used in that function).</p>
<p>For example, if the constants M and N are known to be positive, it is beneficial to provide such an information to the Tiramisu compiler as follows: f.add_context_constraints("[N,M]-&gt;{: M&gt;0 and N&gt;0}"); This context set indicates that the two parameters N and M are strictly positive in the function f.</p>
<p><code>new_context</code> should have the same space as the context set. This call intersects the set <code>new_context</code> (input) with the context of the function. </p>

</div>
</div>
<a class="anchor" id="ab4011e84bbce53bf12f3d27d268f3ec6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::add_gpu_block_dimensions </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>stmt_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim1</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim2</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag the dimensions <code>dim0</code>, <code>dim1</code> and <code>dim2</code> of the computation <code>computation_name</code> to be mapped to GPU blocks. </p>
<p>The dimension 0 represents the outermost loop level (it corresponds to the leftmost dimension in the iteration space).</p>
<p>If the user does not want to tag <code>dim1</code> or <code>dim2</code>, he can leave their values to default value (i.e., -1). They will not be tagged.</p>
<p>For example</p>
<p>add_gpu_block_dimensions("S0", 1, 2);</p>
<p>Will tag the dimensions 1 and 2 to be transformed to GPU blocks. </p>

</div>
</div>
<a class="anchor" id="a172616662673576c9e6a2338e79e2405"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::add_gpu_thread_dimensions </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>stmt_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim1</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim2</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag the dimensions <code>dim0</code>, <code>dim1</code> and <code>dim2</code> of the computation <code>computation_name</code> to be mapped to GPU threads. </p>
<p>The dimension 0 represents the outermost loop level (it corresponds to the leftmost dimension in the iteration space).</p>
<p>If the user does not want to tag <code>dim1</code> or <code>dim2</code>, he can leave their values to default value (i.e., -1). They will not be tagged.</p>
<p>For example</p>
<p>add_gpu_block_dimensions("S0", 1, -1, -1);</p>
<p>Will tag the dimension 1 to be transformed to GPU threads. </p>

</div>
</div>
<a class="anchor" id="ab23c049224f7978085814d78192072fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::add_invariant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1constant.html">tiramisu::constant</a>&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an invariant to the function. </p>

</div>
</div>
<a class="anchor" id="a606a6a8f4743b80e88624335c7d6aa80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::add_iterator_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>it_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an iterator to the function. </p>

</div>
</div>
<a class="anchor" id="ab166ee0cecf4afec3d75e17662976e20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::align_schedules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Align the schedules of all the computations of this function. </p>
<p>This method applies to the schedule of each computation in the function. It makes the dimensions of the ranges of all the schedules equal. This is done by adding dimensions equal to 0 to the range of each schedule. This function is called automatically when <a class="el" href="classtiramisu_1_1function.html#ab5792d0b53936a1ab74d2615810adbd4" title="Generate an isl AST that represents the function. ">gen_isl_ast()</a> or gen_time_processor_domain() are called. </p>

</div>
</div>
<a class="anchor" id="af3e42f31722b17263102734867aaaa71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::allocate_and_map_buffers_automatically </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each computation, allocate a buffer and map the computation to that buffer. </p>
<p>For each computation in the function:</p><ul>
<li>Allocate a buffer where the size of the buffer is derived automatically. Assuming the name of the computation is C, the name of the generated buffer is _C_buffer.</li>
<li>Map the computation to the allocated buffer (one-to-one mapping). For more details about one-to-one mapping, see <a class="el" href="classtiramisu_1_1computation.html#a284f6a8c4a388d15ffa3b40bbfaf5693" title="Bind this computation to a buffer. ">computation::store_in</a>. </li>
</ul>

</div>
</div>
<a class="anchor" id="a1958c4935e7f81bf6b5e8853c2116f39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::codegen </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>obj_filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for all the functions required to run code generation of a tiramisu program. </p>

</div>
</div>
<a class="anchor" id="af5662551a604ffea619b3bbe385120d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::compute_bounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the bounds of each computation. </p>
<p>Computing the bounds of each computation means computing the constraints over the iteration domains of each computation in the function.</p>
<p>In order to deduce bounds, Tiramisu first identifies the final consumers in the function (i.e., computations that do not have any consumer). Then, it propagates the bounds over the final consumers to their producers. The bounds of each consumer are used to deduce the bounds over its producer.</p>
<p>To take benefit of bound inference, the user can declare computations without providing constraints on their iteration domains. For example the user can declare the following computations (the left side is the iteration domain, while the right side is the expression attached to each computation)</p>
<div class="fragment"><div class="line">{A[i]        } : 0</div><div class="line">{B[i]        } : 0</div><div class="line">{C[i]        } : A[i] + B[i]</div><div class="line">{D[i]: 0&lt;=i&lt;N} : 2*C[i]</div></div><!-- fragment --><p>The user needs only to provide constraints over the domains of the last computations (last consumers), and Tiramisu will propagate these constraints to all the chain of computations that produce for those consumers. In the previous example, constraints over the iteration domain were only provided for the last consumer "D[i]" and no constraints were provided for the other computations. Bound inference would deduce the constraints for the computations A[i], B[i] and C[i].</p>
<p>Note that bound inference is not possible if you have multiple definitions of the same computation. For example, if you have multiple definitions of the same computations, in such a case the user should provide constraints of the iteration domain of the computation. Example:</p>
<div class="fragment"><div class="line">{A[i]        } : 0</div><div class="line">{C[i]: i=0   } : 0</div><div class="line">{C[i]: 1&lt;=i&lt;N} : C[i-1] + A[i]</div><div class="line">{D[i]: 0&lt;=i&lt;N} : 2*C[i]</div></div><!-- fragment --><p>In this case, constraints over the computations defining C[i] should be provided. </p>

</div>
</div>
<a class="anchor" id="ad853d05e691fa26254177c09d5157d10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_union_map* tiramisu::function::compute_dep_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the graph of dependences between the computations of the function. </p>
<p>Example</p>
<p>C[0] = 0 D[1] = C[0] D[2] = C[0] {C[0] -&gt; D[1]; C[0]-&gt;D[2]} </p>

</div>
</div>
<a class="anchor" id="a804d3b074034a155e0c048bb819b96e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::dump </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exhaustive</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the function on standard output (dump most of the fields of <a class="el" href="classtiramisu_1_1function.html" title="A class to represent functions in Tiramisu. ">tiramisu::function</a>). </p>
<p>This is mainly useful for debugging. If <code>exhaustive</code> is set to true, all the fields of the function class are printed. </p>

</div>
</div>
<a class="anchor" id="a70c65ca8d0b7e7f814e8af97034845e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::dump_dep_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the graph of dependences between computations. </p>
<p>The graph of dependences is a union of maps (relations) from producers to consumers. </p>

</div>
</div>
<a class="anchor" id="a346628909ccc3bf0f4e836582a47369c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::dump_halide_stmt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a Halide stmt that represents the function. </p>
<p><a class="el" href="classtiramisu_1_1function.html#abd658a57a2a7fce5955ca86405230b89" title="Generate a Halide stmt that represents the function. ">tiramisu::function::gen_halide_stmt</a> should be called before calling this function. </p>

</div>
</div>
<a class="anchor" id="a9967fb7d74a924e8e479ac6ee8aa0f3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::dump_iteration_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the iteration domain of the function. </p>
<p>This is mainly useful for debugging. </p>

</div>
</div>
<a class="anchor" id="aba881339599024ba4424f5e96496e13b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::dump_sched_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps the graph of scheduling relations set by the higher level scheduling functions (e.g. </p>
<p>after, before, compute_at...).</p>
<p>This is mainly useful for debugging. This function can be called at any point during scheduling. </p>

</div>
</div>
<a class="anchor" id="a11a4ca9fa5e9577dbb1457642a08771e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::dump_schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the schedules of the computations of the function. </p>
<p>This function is mainly useful for debugging. See tiramisu::computations::set_low_level_schedule for details about the schedule. </p>

</div>
</div>
<a class="anchor" id="abdf3c028806e84b71daf03140ecd2b26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::dump_time_processor_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump (on stdout) the time processor domain of the function. </p>
<p>The time-processor domain should be generated using tiramisu::function::gen_time_processor_domain before calling this function. This is mainly useful for debugging. </p>

</div>
</div>
<a class="anchor" id="a0a00f945e60bc4c1188345201cbb1c26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::dump_trimmed_time_processor_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump (on stdout) the trimmed time processor domain of the function. </p>
<p>The time-processor domain should be generated using tiramisu::function::gen_time_processor_domain before calling this function. This is mainly useful for debugging. The difference between the time-processor domain and the trimmed time-processor domain is that the trimmed one does not have the duplicate dimension. We remove it before printing. The trimmed time-processor domain is the domain used for code generation. </p>

</div>
</div>
<a class="anchor" id="a330d325efaa557465e583c464fc3e4ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::gen_c_code </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate C code and print it on stdout. </p>
<p>Currently C code code generation is very basic and does not support many features compared to the Halide code generator. Use this for debugging only. </p>

</div>
</div>
<a class="anchor" id="a919fa276486c0348dd626a3e75d10f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::gen_cuda_stmt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3a7dc392ea116258b7b66bcf3ef94c72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::gen_halide_obj </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>obj_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Halide::Target::OS&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Halide::Target::Arch&#160;</td>
          <td class="paramname"><em>arch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an object file that contains the compiled function. </p>
<p>This function relies on Halide to generate the object file.</p>
<p><code>obj_file_name</code> indicates the name of the generated file.</p>
<p><code>os</code> indicates the target operating system (Halide::Target::OS).</p>
<p><code>arch</code> indicates the architecture of the target (the instruction set).</p>
<p><code>bits</code> indicate the bit-width of the target machine. must be 0 for unknown, or 32 or 64. For a full list of supported values for <code>os</code> and <code>arch</code> please check the documentation of Halide::Target (<a href="http://halide-lang.org/docs/struct_halide_1_1_target.html">http://halide-lang.org/docs/struct_halide_1_1_target.html</a>). If the machine parameters are not supplied, Halide detects the parameters of the host machine automatically. </p>

</div>
</div>
<a class="anchor" id="ac59a7d760c7fc07075ca0e94bc8d99c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::gen_halide_obj </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>obj_file_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="abd658a57a2a7fce5955ca86405230b89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::gen_halide_stmt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a Halide stmt that represents the function. </p>

</div>
</div>
<a class="anchor" id="ab5792d0b53936a1ab74d2615810adbd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::gen_isl_ast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an isl AST that represents the function. </p>

</div>
</div>
<a class="anchor" id="ab62a0194f9dbc0d549fa8074fa920411"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::gen_ordering_schedules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the schedules of the computations of this function to reflect the order specified using the high level scheduling commands. </p>
<p>Commands like .after() and .before() do not directly modify the schedules but rather modify the sched_graph graph. </p>

</div>
</div>
<a class="anchor" id="a50be3da8d911d89f7bab886a5ac98976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::gen_time_space_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the time-space domain of the function. </p>
<p>In this representation, the logical time of execution and the processor where the computation will be executed are both specified. </p>

</div>
</div>
<a class="anchor" id="abcd78d8fcd7cd75562a9fb9703afe1af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> *&gt;&amp; tiramisu::function::get_arguments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the arguments of the function. </p>

</div>
</div>
<a class="anchor" id="abd7cb24ba7f1a77c00e2dabc3efa167b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, <a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> *&gt;&amp; tiramisu::function::get_buffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a map that represents the buffers of the function. </p>
<p>The buffers of the function are buffers that are either passed to the function as arguments or are buffers that are declared and allocated within the function itself. The names of the buffers are used as a key for the map. </p>

</div>
</div>
<a class="anchor" id="a3adefae8a99b33f2c78081ea4f012b3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classtiramisu_1_1computation.html">computation</a> *&gt; tiramisu::function::get_computation_by_name </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the computation of the function that has the name <code>str</code>. </p>

</div>
</div>
<a class="anchor" id="ad9aa0fde85ccad6193fb744e53cd104d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classtiramisu_1_1computation.html">computation</a> *&gt;&amp; tiramisu::function::get_computations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector of the computations of the function. </p>
<p>The order of the computations in the vector does not have any effect on the actual order of execution of the computations. The order of execution of computations is specified through the schedule. </p>

</div>
</div>
<a class="anchor" id="af573a260ce03fd48571e102ccf8c3c8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string tiramisu::function::get_gpu_block_iterator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string representing the name of the GPU block iterator at dimension <code>lev0</code>. </p>
<p>This function only returns a non-empty string if the computation <code>comp</code> is mapped to a GPU block at the dimension <code>lev0</code>. </p>

</div>
</div>
<a class="anchor" id="afa73e0ae4d3e1af91a17c2cf8236dedd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string tiramisu::function::get_gpu_thread_iterator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string representing the name of the GPU thread iterator at dimension <code>lev0</code>. </p>
<p>This function only returns a non-empty string if the computation <code>comp</code> is mapped to a GPU thread at the dimension <code>lev0</code>. </p>

</div>
</div>
<a class="anchor" id="ae3ec5f97912774ffcd55e1c0423071e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Internal::Stmt tiramisu::function::get_halide_stmt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the Halide statement that represents the whole function. </p>
<p>The Halide statement is generated by the code generator. This function should not be called before calling the code generator. </p>

</div>
</div>
<a class="anchor" id="a2948ab3eda80bb89ad5ee594e36fbe3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classtiramisu_1_1constant.html">tiramisu::constant</a>&gt;&amp; tiramisu::function::get_invariants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector representing the invariants of the function (symbolic constants or variables that are invariant to the function i.e. </p>
<p>do not change their value during the execution of the function). </p>

</div>
</div>
<a class="anchor" id="a574ee164e7f7d0ae9d8beb9e8abe19d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_ast_node* tiramisu::function::get_isl_ast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an ISL AST that represents this function. </p>
<p>This function itself does not generate the ISL AST, it just returns it if it already exists. The function <a class="el" href="classtiramisu_1_1function.html#ab5792d0b53936a1ab74d2615810adbd4" title="Generate an isl AST that represents the function. ">gen_isl_ast()</a> should be called before calling this function. </p>

</div>
</div>
<a class="anchor" id="a0c248d059bd2905af000ad983bfde2dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_ctx* tiramisu::function::get_isl_ctx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the isl_ctx associated with this function. </p>
<p>This is an ISL specific object required when calling certain ISL functions. It does not represent the set of parameters of the function (which should be retrieved by calling <a class="el" href="classtiramisu_1_1function.html#aef38c08c63bc4b506e47dbad01c58f8f" title="Return a set that represents the parameters of the function (an ISL set that represents the parameter...">get_program_context()</a>). </p>

</div>
</div>
<a class="anchor" id="ab341842b5cab456e095b2f1fa9488d2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_union_set* tiramisu::function::get_iteration_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the union of all the iteration domains of the computations of the function. </p>

</div>
</div>
<a class="anchor" id="add2aa299e2469b8b2d7d09ea24efa545"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; tiramisu::function::get_iterator_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the iterator names of the function. </p>

</div>
</div>
<a class="anchor" id="afb0da0ef300285b84602af5c461ece41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; tiramisu::function::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the function. </p>

</div>
</div>
<a class="anchor" id="aef38c08c63bc4b506e47dbad01c58f8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_set* tiramisu::function::get_program_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a set that represents the parameters of the function (an ISL set that represents the parameters and constraints over the parameters of the functions, a parameter is an invariant of the function). </p>
<p>This set is also known as the context of the program. An example of a context set is the following: "[N,M]-&gt;{: M&gt;0 and N&gt;0}" This context set indicates that the two parameters N and M are strictly positive. </p>

</div>
</div>
<a class="anchor" id="a2e2bde943038dda60f25e8e9e6eb0c6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_union_map* tiramisu::function::get_schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the union of all the schedules of the computations of the function. </p>

</div>
</div>
<a class="anchor" id="afd4eb660feb5cf67aec94a758defc315"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_union_set* tiramisu::function::get_time_processor_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the union of time-processor domains of each computation in the function. </p>
<p>In the time-processor representation, the logical time of execution and the processor where the computation will be executed are both specified. </p>

</div>
</div>
<a class="anchor" id="afae5ec8c162c8ca1a5c8e444f1296958"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_union_map* tiramisu::function::get_trimmed_schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the union of all the trimmed schedules of the function. </p>
<p>A trimmed schedule is the schedule without the duplication dimension (the schedule dimension used to indicate duplicate computations). </p>

</div>
</div>
<a class="anchor" id="ac20cd533003fcf31d7aba5829cafcd49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int tiramisu::function::get_vector_length </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the computation <code>comp</code> is vectorized, return its vector length at the loop level <code>lev</code>. </p>

</div>
</div>
<a class="anchor" id="af00c5c93c40c6ba0d8779a6c623b3db4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::function::is_sched_graph_tree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the usage of high level scheduling comments is valid; i.e. </p>
<p>if the scheduling relations formed using before, after, compute_at, etc.. form a tree.</p>
<p>More specifically, it verifies that:</p><ul>
<li>There should be exactly one computation with no computation scheduled before it.</li>
<li>Each other computation should have exactly one computation scheduled before it. </li>
</ul>

</div>
</div>
<a class="anchor" id="a59b42857aaf7ff54007d5b67efa2d298"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::lift_dist_comps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lift certain computations for distributed execution to function calls. </p>

</div>
</div>
<a class="anchor" id="ab5bbaacf8f539fbe2cdcb72f109c1ad6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::lift_mpi_comp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lift certain computations for distributed execution to function calls. </p>

</div>
</div>
<a class="anchor" id="a96bdda918ab1e5dee9aa4adeeff053a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::function::needs_rank_call </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This computation requires a call to the MPI_Comm_rank function. </p>

</div>
</div>
<a class="anchor" id="af1ae28c38afbfbd44b8c73ceb323ec76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::set_arguments </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the arguments of the function. </p>
<p>The arguments of the function are provided as a vector of pointers to buffers. Each buffer represents an argument to the function. During code generation, the arguments in the vector will become the arguments of the generated function (with the order of their appearance in the vector). </p>

</div>
</div>
<a class="anchor" id="a1f58920ccc2ae149c678e452693a2d9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::set_context_set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the context of the function. </p>
<p>A context is an ISL set that represents constraints over the parameters of the functions (a parameter is an invariant variable for the function). An example of a context set is the following: "[N,M]-&gt;{: M&gt;0 and N&gt;0}" This context set indicates that the two parameters N and M are strictly positive.</p>
<p>This function takes a string that represents and ISL set. </p>

</div>
</div>
<a class="anchor" id="ab07666f6b68d13ebe0a436c397908e02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::set_context_set </td>
          <td>(</td>
          <td class="paramtype">isl_set *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.This function takes an ISL set as input. </p>

</div>
</div>
<a class="anchor" id="a4e91d4e3ffd5bf6127156ab45fc32e88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::set_iterator_names </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>it_names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the iterator names of the function. </p>
<p>This function overrides any previously set iterator names. </p>

</div>
</div>
<a class="anchor" id="a30b34f98c6c6b7759a21a73d610b7f23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::function::should_distribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the computation <code>comp</code> should be distributed at the loop level <code>lev</code>. </p>

</div>
</div>
<a class="anchor" id="ad2392e3cfb3c84a8a58c3ca5941d0d50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::function::should_map_to_gpu_block </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the computation <code>comp</code> should be mapped to GPU block at the loop levels <code>lev0</code>. </p>

</div>
</div>
<a class="anchor" id="a0a999642c7e6a817d17660ff731f9412"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::function::should_map_to_gpu_thread </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the computation <code>comp</code> should be mapped to GPU thread at the loop levels <code>lev0</code>. </p>

</div>
</div>
<a class="anchor" id="aea6b081a16ce8f0ac126e17189bff492"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::function::should_parallelize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the computation <code>comp</code> should be parallelized at the loop level <code>lev</code>. </p>

</div>
</div>
<a class="anchor" id="a2ed66bde408f35cd4fdb8b5ae792ec0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::function::should_unroll </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the computation <code>comp</code> should be unrolled at the loop level <code>lev</code>. </p>

</div>
</div>
<a class="anchor" id="a2ce1b2d76899284621d2fb8b42ae7237"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::function::should_vectorize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the computation <code>comp</code> should be vectorized at the loop level <code>lev</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a8ec5724b5bbb47dcfa8571f855d20bbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *&gt; tiramisu::function::automatically_allocated</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keeps track of allocation computations created using allocate_and_map_buffer_automatically() to schedule them during gen_ordering_schedules. </p>

<p>Definition at line <a class="el" href="core_8h_source.html#l00439">439</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<a class="anchor" id="a865002ee46e628ee370bdbfa2be9e0d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *, std::unordered_map&lt;<a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *, int&gt; &gt; tiramisu::function::sched_graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores all high level scheduling instructions between computations; i.e. </p>
<p>if a user calls for example c2.after(c1, L), sched_graph[&amp;c1] would contain the key &amp;c2, and sched_graph[&amp;c1][&amp;c2] = L. At the end of scheduling, the graph should respect the following rules:</p><ul>
<li>There should be exactly one computation with no computation scheduled before it.</li>
<li>Each other computation should have exactly one computation scheduled before it. In other words, the graph should be a valid tree. Does not include allocation computations created using allocate_and_map_buffer_automatically(). </li>
</ul>

<p>Definition at line <a class="el" href="core_8h_source.html#l00624">624</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeb348adb9016451a8eeb799705455edd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *, std::unordered_map&lt;<a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *, int&gt; &gt; tiramisu::function::sched_graph_reversed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as sched_graph, except in reverse order (from after to before). </p>

<p>Definition at line <a class="el" href="core_8h_source.html#l00630">630</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<a class="anchor" id="a587856ea73f0f552cc711091a3b8ced8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt;<a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *&gt; tiramisu::function::starting_computations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set of all computations that have no computation scheduled before them. </p>
<p>Does not include allocation computations created using allocate_and_map_buffer_automatically(). </p>

<p>Definition at line <a class="el" href="core_8h_source.html#l00694">694</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<a class="anchor" id="a67c71ad05ac2b8c0312dc5ab667e0cf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::function::use_low_level_scheduling_commands</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A boolean set to true if low level scheduling was used in the program. </p>
<p>If it is used, then high level scheduling commands such as .before(), .after(), ... </p>

<p>Definition at line <a class="el" href="core_8h_source.html#l00701">701</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="core_8h_source.html">core.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetiramisu.html">tiramisu</a></li><li class="navelem"><a class="el" href="classtiramisu_1_1function.html">function</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
